#include <iostream>
using namespace std;
//TODO:
//Каждая переменная имеет свою область видимости, то есть такую область,
//в которой можно работать с переменной.  За пределами этой области, о
//данной переменной ничего известно не будет, а значит и использовать её
//нельзя. Итак, переменная  находится в области видимости, если к ней можно
//получить доступ.
//
//Существуют локальные и глобальные переменные. Так вот, переменные, объявленные
//внутри функции, называются локальными. Локальные переменные имеют свои области
//видимости, этими областями являются функции, в которых объявлены переменные.
//Таким образом, в разных функциях можно использовать переменные с одинаковыми именами,
//что в свою очередь очень удобно. Разделение переменных на глобальные и локальные
//соответствует одному из главных правил программирования, а именно – принципу
//наименьших привилегий. То есть, переменные, объявленные внутри одной функции, должны
//быть доступны только для этой функции и ни чему другому, в конце концов, они создавались
//именно для этой функции.   Глобальные переменные объявляются вне тела какой-либо функции,
//и поэтому область видимости таких переменных распространяется на всю программу.
//Обычно глобальные переменные объявляются перед главной функцией, но можно объявлять
//и после функции main(), но тогда данная переменная не будет доступна в функции main().

//Разработаем программу, в которой будут объявлены две переменные, локальная и глобальная, с одинаковым именем.

void example1();

int variable = 48; // инициализация глобальной переменной

int main1(int argc, char *argv[]) {
    int variable = 12; // инициализация локально переменной
    cout << "local  variable = " << variable << endl; // печать значения содержащегося в локальной переменной
    example1(); // запуск функции
    system("pause");
    return 0;
}

void example1() {
    cout << "global variable = " << variable << endl; // функция видит только глобальную переменную
}

//В строках 8 и 12 объявлены переменные одинакового типа с одним и тем же именем variable, но переменная
//в строке 8 является глобальной переменной, а переменная в строке 12 — это локальная переменная.
//Функция example1() имеет доступ  только к глобальной переменной. В то время как функция main1() имеет доступ
//как к локальной так и к глобальной переменным. Если в области видимости есть и локальная и глобальная
//переменные с одинаковыми именами, то при обращении к ним, будет использоваться ближайшая переменная,
//а это локальная переменная, это видно по результату работы программы

//        local  variable = 12
//        global variable = 48

//Как мы уже сказали, функция main1() имеет доступ и к глобальной переменной, но не
//показали, как получить этот доступ. В С++ существует такая операция, как разрешение
//области действия ::. Эта операция позволяет  обращаться к глобальной переменной из
//любого места программы.» Все, что нужно сделать, так это поставить двойное двоеточие
//перед именем переменной.  Ниже показан код, верхней программы с одним лишь изменением

void example();

int main(int argc, char *argv[]) {
    int variable = 12; // инициализация локально переменной
    cout << "local  variable = " << ::variable << endl; // печать значения содержащегося в глобальной переменной
    example(); // запуск функции
    system("pause");
    return 0;
}

void example() {
    cout << "global variable = " << variable << endl; // функция видит только глобальную переменную
}
//Операция разрешения области действия ставится перед именем глобальной переменной, и
//даже, если есть локальная переменная с таким же именем, программа будет работать со
//значением, содержащимся в глобальной переменной.

//        local  variable = 48
//        global variable = 48

//TODO:
//Статические локальные переменные
//        Когда static применяется к локальной переменной, это приводит к тому, что компилятор
//        создает долговременную область для хранения переменной почти таким же способом, как это
//        делается для глобальной переменной. Ключевое различие между статической локальной и
//        глобальной переменными заключается в том, что статическая локальная переменная остается
//        известной только в том блоке, в котором она была объявлена. Проще говоря, статическая
//        локальная переменная - это локальная переменная, сохраняющая свое значение между вызовами функций.
//
//Наличие статических локальных переменных очень важно для создания самостоятельных функций поскольку
//имеется несколько типов подпрограмм, сохраняющих значение между вызовами. Если использование статических
//переменных недопустимо, то следует использовать глобальные переменные, но это может привести к побочным
//эффектам. Ниже приведен простой пример того, как статитеская локальная переменная может использоваться
//в функции count():

int count(int i);

int main2() {
    for (int i = 0; i < 7; i++) {
        count(0);
    }
    printf("count called %d times", count(1));
    return 0;
}

int count(int i) {
    static int c = 0;
    if (i == 1){
        return c;
    }else{
        c++;
    }
    return 0;
}

//Иногда полезно знать, как часто функция вызывается во время работы программы. Это
//возможно сделать через использование глобальных переменных, но лучшим вариантом является
//использование функции, сохраняющей информацию внутри себя, как это сделано в функции count().
//В данном примере, если count() вызывается со значением 0, то переменная с увеличивается.
//(Скорее всего в настоящих приложениях функция будет также выполнять некоторую другую полезную работу.)
//Если count() вызывается с любым другим значением, то она возвращает число сделанных вызовов.
//Подсчет числа вызовов функции может быть полезен при разработке программы, которая вызывает эти
//функции достаточно часто, и требуется привлечь к вызовам внимание.

//Другим хорошим примером функции, требующей использования статических локальных переменных, является
//генератор последовательности чисел, создающий новое число, основываясь на старом. Это можно сделать,
//объявив глобальную переменную. Тем не менее, каждый раз, когда функция используется в программе,
//следует помнить об объявлении глобальной переменной и постоянно необходимо смотреть: не конфликтует
//ли переменная с другими, ранее объявленными, переменными. Также использование глобальной переменной
//приводит к тому, что функцию трудно поместить в библиотеку функций. Лучшим решением является
//объявление переменной, содержащей сгенерированное число как static, как в нижеприведенном фрагменте.

int series() {
    static int series_num;
    series_num = series_num + 23;
    return (series_num);
}
//
//В данном примере переменная series_num существует между вызовами функций вместо того,
//чтобы каждый раз создаваться и уничтожаться как обычная локальная переменная. Это означает,
//что каждый вызов series() может создать новый член серии, основываясь на последнем члене
//без глобального объявления переменной.

//Можно было заметить нечто необычное в функции series(). Статическая переменная series_num не инициализируется.
//Это означает, что при первом вызове функции series_num имеет значение по умолчанию 0. Хотя это приемлемо
//для некоторых приложений, большинство генераторов последовательности требуют какую-либо другую стартовую точку.
//Чтобы сделать это, требуется инициализировать series_num до первого вызова series(), что может быть легко
//сделано, если series_num является глобальной переменной. Тем не менее, следует избегать использования
//series_num как глобальной переменной и лучше объявить ее как static. Это приводит ко второму способу
//использования static.

//TODO:
//Ключевые слова static и extern
//        В дополнение к области видимости и продолжительности жизни, переменные имеют еще
//        одно свойство — связь. Связь переменной определяет, относятся ли несколько упоминаний
//        одного идентификатора к одной и той же переменной или нет.
//
//Переменная без связей — это переменная с локальной областью видимости, которая относится только
//к блоку, в котором она определена. Это обычные локальные переменные. Две переменные с одинаковыми
//именами, но определенные в разных функциях, не имеют никакой связи — каждая из них считается
//независимой единицей.
//
//Переменная, имеющая внутренние связи, называется внутренней переменной (или «статической переменной»).
//Она может использоваться в любом месте файла, в котором определена, но не относится к чему-либо вне этого файла.
//Переменная, имеющая внешние связи, называется внешней переменной. Она может использоваться как в
//файле, в котором определена, так и в других файлах.

//Если вы хотите сделать глобальную переменную внутренней (которую можно использовать только внутри
//одного файла) — используйте ключевое слово static:

static int g_x; // g_x - это статическая глобальная переменная, которую можно использовать только внутри этого файла

//Аналогично, если вы хотите сделать глобальную переменную внешней (которую можно использовать в
//любом файле программы) — используйте ключевое слово extern:

extern double g_y(9.8); // g_y - это внешняя глобальная переменная и её можно использовать и в других файлах программы

//По умолчанию, неконстантные переменные, объявленные вне блока, считаются внешними. Однако
//константные переменные, объявленные вне блока, считаются внутренними.
//
//Предварительные объявления переменных с использованием extern
//        Из урока №20 мы уже знаем, что для использования функций, которые определены в другом файле,
//        нужно применять предварительные объявления.
//
//Аналогично, чтобы использовать внешнюю глобальную переменную, которая была объявлена в другом файле,
//нужно записать предварительное объявление переменной с использованием ключевого слова extern
//(без инициализируемого значения). Например:

//global.cpp:
//
//// Определяем две глобальные переменные
//int g_m; // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
//int g_n(3); // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
//// g_m и g_n можно использовать в любом месте этого файла
//
//// Определяем две глобальные переменные
//int g_m; // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
//int g_n(3); // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
//// g_m и g_n можно использовать в любом месте этого файла
//main.cpp:
//
//#include <iostream>
//
//extern int g_m; // предварительное объявление g_m. Теперь g_m можно использовать в любом месте этого файла
//
//int main(){
//    extern int g_n; // предварительное объявление g_n. Теперь g_n можно использовать только внутри main()
//    g_m = 4;
//    std::cout << g_n; // должно вывести 3
//    return 0;
//}

//Если предварительное объявление находится вне блока, то оно применяется ко всему файлу. Если
//же внутри блока, то оно применяется только к нему.
//
//Если переменная объявлена с помощью ключевого слова static, то получить доступ к ней с помощью
//предварительного объявления не получится. Например:

//constants.cpp:
//
//static const double g_gravity(9.8);
//
//main.cpp:
//
//#include <iostream>
//
//extern const double g_gravity; // не найдет g_gravity в constants.cpp, так как g_gravity является внутренней переменной
//
//int main(){
//    std:: cout << g_gravity; // вызовет ошибку компиляции, так как переменная g_gravity не была определена для использования в main.cpp
//    return 0;
//}

//Обратите внимание, если вы хотите определить неинициализированную неконстантную глобальную переменную,
//то не используйте ключевое слово extern, иначе C++ будет думать, что вы пытаетесь записать
//предварительное объявление.
//
////TODO:
// Связи функций

//Функции имеют такие же свойства связи, что и переменные. По умолчанию они имеют внешнюю связь, которую
//можно сменить на внутреннюю с помощью ключевого слова static:

// Эта функция определена как static и может быть использована только внутри этого файла.
// Попытки доступа к ней через прототип функции будут безуспешными
//static int add(int a, int b){
//    return a + b;
//}
//
//Предварительные объявления функций не нуждаются в ключевом слове extern. Компилятор может
//определить сам (по телу функции): определяете ли вы функцию или пишете её прототип.

//TODO:
//Файловая область видимости vs. Глобальная область видимости
//        Термины «файловая область видимости» и «глобальная область видимости», как правило,
//        вызывают недоумение, и это отчасти объясняется их неофициальным использованием. В теории,
//        в языке C++ все глобальные переменные имеют файловую область видимости. Однако, по факту,
//        термин «файловая область видимости» чаще применяется к внутренним глобальным переменным,
//        а «глобальная область видимости» — к внешним глобальным переменным.
//
//Например, рассмотрим следующую программу:

//global.cpp:
//
//int g_y(3); // внешняя связь по умолчанию
//main.cpp:
//
//#include <iostream>
//
//extern int g_y; // предварительное объявление g_y. Теперь g_y можно использовать в любом месте этого файла
//
//int main()
//{
//    std::cout << g_y; // должно вывести 3
//
//    return 0;

//Переменная g_y имеет файловую область видимости внутри global.cpp. Доступ к этой переменной
//вне файла global.cpp отсутствует. Обратите внимание, хотя эта переменная и используется в
//main.cpp, сам main.cpp не видит её, он видит только предварительное объявление g_y (которое
//также имеет файловую область видимости). Линкер отвечает за связывание определения g_y в
//global.cpp с использованием g_y в main.cpp.

//Глобальные символьные константы
//        На уроке о символьных константах, мы определяли их следующим образом:
//
//constants.h:
//
//#ifndef CONSTANTS_H
//#define CONSTANTS_H
//
//// Определяем отдельное пространство имен для хранения констант
//namespace Constants
//{
//    const double pi(3.14159);
//    const double avogadro(6.0221413e23);
//    const double my_gravity(9.2);
//    // ... другие константы
//}
//#endif
//
//Хоть это просто и отлично подходит для небольших программ, но каждый раз, когда constants.h
//подключается в другой файл, каждая из этих переменных копируется в этот файл. Таким образом,
//если constants.h подключить в 20 различных файлов, то каждая из переменных продублируется 20 раз.
//Header guards не остановят это, так как они только предотвращают подключение заголовочного файла
//более одного раза в один файл. Дублирование переменных на самом деле не является проблемой
//(поскольку константы зачастую не занимают много памяти), но изменение значения одной константы
//потребует перекомпиляции каждого файла, в котором она используется, что может привести к большим
//временным затратам в более крупных проектах.

//Избежать этой проблемы можно, превратив эти константы в константные глобальные переменные, и
//изменив заголовочный файл только для хранения предварительных объявлений переменных. Например:
//
//constants.cpp:
//
//namespace Constants
//{
//    // Фактические глобальные переменные
//    extern const double pi(3.14159);
//    extern const double avogadro(6.0221413e23);
//    extern const double my_gravity(9.2);
//}
//
//
//#ifndef CONSTANTS_H
//#define CONSTANTS_H
//
//namespace Constants
//{
//    // Только предварительные объявления
//    extern const double pi;
//    extern const double avogadro;
//    extern const double my_gravity;
//}
//
//#endif

//Их использование в коде остается неизменным:
//
//#include "constants.h"
//
////...
//double circumference = 2 * radius * Constants::pi;
////...

//Теперь определение символьных констант выполняется только один раз (в constants.cpp).
//Любые изменения, сделанные в constants.cpp, потребуют перекомпиляции только (одного) этого файла.
//
//Но есть и обратная сторона медали: такие константы больше не будут считаться константами
//типа compile-time и, поэтому, не смогут использоваться где-либо, где потребуется константа такого типа.

//Поскольку глобальные символьные константы должны находиться в отдельном пространстве имен и быть доступными
//только для чтения, то использовать префикс g_ уже не обязательно.
//
//Предостережение о (неконстантных) глобальных переменных
//У начинающих программистов часто возникает соблазн использовать просто множество глобальных переменных,
//поскольку с ними легко работать, особенно когда задействовано много функций. Тем не менее, этого
//следует избегать! Почему? Об этом мы поговорим на следующем уроке.

//TODO:
//Заключение
//
//*Глобальные переменные имеют глобальную область видимости и могут использоваться в любом месте
//программы. Подобно функциям, вы должны использовать предварительные объявления (с ключевым словом extern),
//чтобы использовать глобальную переменную, определенную в другом файле.
//
//*По умолчанию, глобальные неконстантные переменные имеют внешнюю связь. Вы можете использовать ключевое
//слово static, чтобы сделать их внутренними.
//
//*По умолчанию, глобальные константные переменные имеют внутреннюю связь. Вы можете использовать ключевое
//слово extern, чтобы сделать их внешними.
//
//*Используйте префикс g_ для идентификации ваших неконстантных глобальных переменных.