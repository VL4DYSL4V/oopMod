//TODO:
//Возможные варианты синтаксиса лямбда функций
//
//[ capture ] ( params ) mutable exception attribute -> ret { body }
//[ capture ] ( params ) -> ret { body }
//[ capture ] ( params ) { body }
//[ capture ] { body }
//Первый вариант является полным, но не запрещается использовать сокращённые вариации записи функций.

//capture - список  внешних захватываемых объектов, они могут захватываться как по ссылке, так и копированием.
//params - список параметров, передаваемых в лямбда функции, данная часть будет аналогична записи
//          аргументов для обычных функций.
//mutable - использование mutable позволяет модифицировать копии объектов, которые были захвачены копированием.
//          В обычном варианте они не будут модифицироваться.
//exception - обеспечивает спецификацию исключения, то есть лямбда функции также как и обычные функции
//          могут выкидывать исключения.
//attribute - обеспечивает спецификацию атрибута, таких атрибутов в спецификации C++ определено всего два
//          ([[noreturn]], [[carries_dependency]])
//                  * params - список параметров, передаваемых в лямбда функцию
//                  * ret - возвращаемое значение лямбда функции

//Что касается возвращаемого значение, то оно может автоматически выводиться из типа объекта,
//который возвращается оператором return. Если же в лямбда-функции отсутствует оператор return,
//то возвращаемое значение будет void.
//
//Лямбда функция создаёт безымянный временный объект уникального безымянного non-union,
//        non-aggregate типа, известного как тип замыкания. Благодаря введению оператора auto в
//        современном стандарте C++ можно объявить объект лямбда функции довольно легко, без
//        прописывания объявления функтора ( std::function ) со всеми апраметрами и возвращаемыми
//        значениями, что делает код более простым и читаемым (для опытного программиста, конечно.
//        Безусловно нужно учитывать то, что новичок быстрее заподозрит неладное, если в объявлении
//        лямбды будет фигурировать std::function, но это уже вопрос практики).

//Вот пример объявления простой лямбда функции, которая будет возвращать тип void ,
//поскольку отсутствует хотя бы один оператор return .

//#include <iostream>
//
//using namespace std;
//
//int main(){
//    auto myLambda = [](){
//        cout << "Hello World!" << endl;
//    };
//    myLambda();
//    return 0;
//}

//Соответственно программный код не скомпилируется, если в лямда-функции будет
//присутствовать два и более оператора return, которые будут возвращать объекты
//разных типов, не связанных между собой иерархией наследования и не способные
//быть приведены к типу базового класса. И даже, если эти объекты имеют базовый
//класс, необходимо будет прописать тип возвращаемого значения, им как раз будет
//указатель на объект базового класса (в общем случае).

//Вот пример кода, который не скомпилируется.

//#include <iostream>
//
//using namespace std;
//
//class A{
//public:
//    A(){}
//};
//
//class B : public A{
//public:
//    B(){}
//};
//
//class C : public A{
//public:
//    C(){}
//};
//
//int main(){
//    auto myLambda = [](int type)
//    {
//        if (type == 0){
//            return new B();
//        }
//        else{
//            return new C();
//        }
//    };
//
//    myLambda(0);
//
//    return 0;
//}
//Нужно указать тип возвращаемого значения

//auto myLambda = [](int type) -> A* // Укажем тип возвращаемого значения
//{
//    if (type == 0)
//    {
//        return new B();
//    }
//    else
//    {
//        return new C();
//    }
//};
//Также ошибка компиляции будет в том случае, если не указать тип возвращаемого значения
// и при этом вы создаёте в куче объект внутри лямбда функции, но в некоторых случаях можете
// вернуть указатель на nullptr. То есть ниже следующий код не скомпилируется.

//#include <iostream>
//
//using namespace std;
//
//class A{
//public:
//    A(){}
//};
//
//
//int main(){
//    auto myLambda = [](int type)
//    {
//        if (type == 0)
//        {
//            return new A();
//        }
//        else
//        {
//            return nullptr;
//        }
//    };
//    myLambda(0);
//    return 0;
//}
//Опять нужно указать тип возвращаемого значения

//auto myLambda = [](int type) -> A* // Укажем тип возвращаемого значения
//{
//    if (type == 0)
//    {
//        return new A();
//    }
//    else
//    {
//        return nullptr;
//    }
//};
//Дело в том, что nullptr - это универсальный тип данных, который в каком-то смысле не
//является типом данных, поскольку его нельзя установить в качестве типа переменной. Но он
//может быть присвоен в качестве значения указателю на объект. Чтобы неявное преобразование
//в данном случае происходило правильно, нужно также указать тип возвращаемого значения.
//
//Также в выше приведённом примере показано, как вызвать лямда функцию и передать в неё параметры.
//Заметили? В данном примере используется параметр int type , в зависимости от которого мы
//возвращаем указатель на созданный объект или nullptr .

//Также в лямбда функциях присутствует понятие захвата переменных. Это означает, что лямбда
//функция может использовать не только переменные, которые передаются ей в качестве параметров,
//но и какие-либо объекты, которые были объявлены вне лямда-функции.
//
//Список символов может быть передан следующим образом:

//[a,&b] где a захвачена по значению, а b захвачена по ссылке.
//[this] захватывает указатель this по значению.
//[&] захват всех символов по ссылке
//[=] захват всех символов по значению
//[] ничего не захватывает
//        Про захват переменных поговорим в следующих статьях.

//Но отмечу один интересный момент, лямда-функцию можно вызвать сразу же там, где вы её и объявили,
//если добавить после тела лямда функции круглые скобки и передать все необходимые параметры, если они имеются.

//Например такой код тоже скомпилируется
//
//#include <iostream>
//
//using namespace std;
//
//class A{
//public:
//    A(){}
//};
//
//
//int main(){
//
//    A* myA = [](int type) -> A*
//    {
//        if (type == 0)
//        {
//            return new A();
//        }
//        else
//        {
//            return nullptr;
//        }
//    }(0);
//
//    return 0;
//}

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <functional>

class Person {

public:
    Person(int age, std::string name) {
        this->name = name;
        this->age = age;
    }

    int getAge() const {
        return age;
    }

    const std::string &getName() const {
        return name;
    }

private:
    int age;
    std::string name;

};

bool compareByAge(const Person &p1, const Person &p2) {
    return p1.getAge() < p2.getAge();
};

std::function<bool (Person p)> secondOrder(int oldAge){
    auto oper2 = [oldAge](Person p) -> bool {return p.getAge() > oldAge;};
    return oper2;
}

int main() {
    std::vector<Person> people = {Person(20, "Alex"),
                                  Person(34, "Petr"),
                                  Person(18, "Stepan")};
    std::sort(people.begin(), people.end(), compareByAge);
    for (auto i = people.begin(); i < people.end(); i++) {
        std::cout << (*i).getAge() << " " << (*i).getName() << std::endl;
    }
    std::cout << "**************" << std::endl;
    std::sort(people.begin(), people.end(),
              [](const Person &a, const Person &b) -> bool {
                  return a.getAge() > b.getAge();
              });
    for (auto i = people.begin(); i < people.end(); i++) {
        std::cout << (*i).getAge() << " " << (*i).getName() << std::endl;
    }
    auto filtered = std::find_if(people.begin(), people.end(),
                                 [](Person p) -> bool {
                                     return p.getName().length() > 4;
                                 });
    std::cout << filtered->getName() << std::endl;
    const int oldAge = 20;
    auto oper = [](Person p) -> bool {return p.getAge() > oldAge;}; //  Closure
    std::string name = "aaaaa";
    auto oper2 = [name](Person p) -> bool {return p.getName() > name;};
    auto oper3 = [& name](Person p) -> bool {return p.getName() > name;};

    auto oper4 = [& ](Person p) -> bool {return p.getName() > name;}; //capture all by reference
    auto oper5 = [= ](Person p) -> bool {return p.getName() > name;}; //capture all by copy
    std::cout << oper(Person(34, "Vladislav"))<< std::endl;

    auto f1 = secondOrder(20);
    std::cout << f1(Person(10, "Vladislav")) << std::endl;
    return 0;
}

//TODO:
//Указатель на функцию может передаваться в другую функцию в качестве параметра. Например:

int add(int, int);
int subtract(int, int);
int operation(int(*)(int, int), int, int); // вот єто - ф-я 2-го порядка,
                                            // поскольку она принимает в кач-ве арг-та другую ф-ю

int main3(){
    int a = 10;
    int b = 5;
    int result;
    result = operation(add, a, b);
    std::cout << "result: " << result << std::endl;

    result = operation(subtract, a, b);
    std::cout << "result: " << result << std::endl;
    return 0;
}

int add(int x, int y){
    return x + y;
}
int subtract(int x, int y){
    return x - y;
}
int operation(int(*op)(int, int), int a, int b){
    return op(a, b);
}

//В данном случае первый параметр функции operation - int (*op)(int, int) - представляет
//указатель на функцию, которая возвращает значение типа int и принимает два параметра типа int.
//Результатом функции является вызов той функции, на которую указывает указатель.

//Определению указателя соответствуют две функции: add и subtract, поэтому их адрес можно
//передать в вызов функции operation: operation(add, a, b);.

                    //result: 15
                    //result: 5

//Другой пример - функция, которая может принимать в качестве параметра некоторое условие:

#include <iostream>

int isEven(int);
int isPositive(int);
void action(int(*)(int), int[], int);

int main4(){
    int nums[] = { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };
    int n = sizeof(nums) / sizeof(nums[0]);

    std::cout << "Even numbers: " << std::endl;
    action(isEven, nums, n);

    std::cout << "Positive numbers: " << std::endl;
    action(isPositive, nums, n);

    return 0;
}
int isEven(int x){
    return x % 2 == 0;
}
int isPositive(int x){
    return x>0;
}
void action(int(*condition)(int), int numbers[], int n){
    for (int i = 0; i<n; i++){
        if (condition(numbers[i]) != 0){
            std::cout << numbers[i] << "\t";
        }
    }
    std::cout << std::endl;
}
//Первый параметр функции action - указатель int (*condition)(int) представляет функцию,
//которая принимает целое число и в зависимости от того, соответствует оно условию или нет,
//возвращает 1 (если соответствует) или 0. На момент определения функции action точное
//условие может быть неизвестно.
//
//В текущей программе условия представлены двумя функциями. Функция isEven() возвращает 1,
//если число четное, и 0, если число нечетное. А функция isPositive() возвращает 1, если число
//положительное, и 0, если отрицательное.
//
//При вызове функции action() в нее можно передать нужное условие: action(isEven, nums, n);. В
//итоге программа выведет на экран числа из массива nums, которые соответствуют переданному условию:

                    //Even numbers:	-4	-2	0	2	4
                    //Positive numbers:	1	2	3	4	5

//TODO:
//Замыкание (англ. closure) в программировании — функция первого класса, в теле которой
//присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и
//не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается
//на свободные переменные в своей области видимости.
//
//Замыкание, так же как и экземпляр объекта, есть способ представления функциональности
//и данных, связанных и упакованных вместе.
//
//Замыкание — это особый вид функции. Она определена в теле другой функции и создаётся
//каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся
//целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки на
//локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит
//создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.
//
//В случае замыкания ссылки на переменные внешней функции действительны внутри вложенной
//функции до тех пор, пока работает вложенная функция, даже если внешняя функция закончила работу,
//и переменные вышли из области видимости.[1]
//
//Замыкание связывает код функции с её лексическим окружением (местом, в котором она определена
//в коде). Лексические переменные замыкания отличаются от глобальных переменных тем, что они не
//занимают глобальное пространство имён. От переменных в объектах они отличаются тем, что привязаны
//к функциям, а не объектам.

//def anotherfunc(h):
//    def func(): return h
//    return func
//
//print anotherfunc(10)()
    // 10